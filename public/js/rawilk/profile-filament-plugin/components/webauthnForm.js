function N(e){return new TextEncoder().encode(e)}function h(e){let t=new Uint8Array(e),n="";for(let r of t)n+=String.fromCharCode(r);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function E(e){let t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,i=t.padEnd(t.length+n,"="),r=atob(i),l=new ArrayBuffer(r.length),a=new Uint8Array(l);for(let u=0;u<r.length;u++)a[u]=r.charCodeAt(u);return l}function w(){return window?.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential=="function"}function P(e){let{id:t}=e;return{...e,id:E(t),transports:e.transports}}function _(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}var s=class extends Error{constructor({message:t,code:n,cause:i,name:r}){super(t,{cause:i}),this.name=r??i.name,this.code=n}};function U({error:e,options:t}){let{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new s({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(n.authenticatorSelection?.requireResidentKey===!0)return new s({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(n.authenticatorSelection?.userVerification==="required")return new s({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new s({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(r=>r.type==="public-key").length===0?new s({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new s({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){let i=window.location.hostname;if(_(i)){if(n.rp.id!==i)return new s({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new s({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new s({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}var R=class{createNewAbortSignal(){if(this.controller){let n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}let t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){let t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}},I=new R,v=["cross-platform","platform"];function C(e){if(e&&!(v.indexOf(e)<0))return e}async function S(e){if(!w())throw new Error("WebAuthn is not supported in this browser");let n={publicKey:{...e,challenge:E(e.challenge),user:{...e.user,id:N(e.user.id)},excludeCredentials:e.excludeCredentials?.map(P)}};n.signal=I.createNewAbortSignal();let i;try{i=await navigator.credentials.create(n)}catch(c){throw U({error:c,options:n})}if(!i)throw new Error("Registration was not completed");let{id:r,rawId:l,response:a,type:u}=i,d;typeof a.getTransports=="function"&&(d=a.getTransports());let b;if(typeof a.getPublicKeyAlgorithm=="function")try{b=a.getPublicKeyAlgorithm()}catch(c){m("getPublicKeyAlgorithm()",c)}let p;if(typeof a.getPublicKey=="function")try{let c=a.getPublicKey();c!==null&&(p=h(c))}catch(c){m("getPublicKey()",c)}let o;if(typeof a.getAuthenticatorData=="function")try{o=h(a.getAuthenticatorData())}catch(c){m("getAuthenticatorData()",c)}return{id:r,rawId:h(l),response:{attestationObject:h(a.attestationObject),clientDataJSON:h(a.clientDataJSON),transports:d,publicKeyAlgorithm:b,publicKey:p,authenticatorData:o},type:u,clientExtensionResults:i.getClientExtensionResults(),authenticatorAttachment:C(i.authenticatorAttachment)}}function m(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function L(e){return new TextDecoder("utf-8").decode(e)}function x(){let e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(t=>t(!1)):e.isConditionalMediationAvailable()}function H({error:e,options:t}){let{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new s({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){let i=window.location.hostname;if(_(i)){if(n.rpId!==i)return new s({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new s({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function T(e,t=!1){if(!w())throw new Error("WebAuthn is not supported in this browser");let n;e.allowCredentials?.length!==0&&(n=e.allowCredentials?.map(P));let i={...e,challenge:E(e.challenge),allowCredentials:n},r={};if(t){if(!await x())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');r.mediation="conditional",i.allowCredentials=[]}r.publicKey=i,r.signal=I.createNewAbortSignal();let l;try{l=await navigator.credentials.get(r)}catch(o){throw H({error:o,options:r})}if(!l)throw new Error("Authentication was not completed");let{id:a,rawId:u,response:d,type:b}=l,p;return d.userHandle&&(p=L(d.userHandle)),{id:a,rawId:h(u),response:{authenticatorData:h(d.authenticatorData),clientDataJSON:h(d.clientDataJSON),signature:h(d.signature),userHandle:p},type:b,clientExtensionResults:l.getClientExtensionResults(),authenticatorAttachment:C(l.authenticatorAttachment)}}var K=()=>{if(document.querySelector('meta[name="csrf-token"]'))return document.querySelector('meta[name="csrf-token"]').getAttribute("content");if(document.querySelector("[data-csrf]"))return document.querySelector("[data-csrf]").getAttribute("data-csrf");if(window.livewireScriptConfig.csrf??!1)return window.livewireScriptConfig.csrf;throw new Error("No CSRF token detected")},V=e=>Array.isArray(e),k=e=>typeof e=="object"&&e!==null,D=e=>k(e)&&!V(e),y=e=>typeof e=="function",A=(e,t)=>t in e;var O=(e={})=>({method:"POST",headers:{"Content-Type":"application/json","X-Webauthn":""},body:JSON.stringify({_token:K(),...e})});function M({mode:e="login",publicKey:t=void 0,wireId:n=void 0,beforeRegister:i=void 0,serverError:r=void 0,registerData:l={},registerPublicKeyUrl:a=void 0,registerMethodName:u="verifyKey",loginPublicKeyUrl:d=void 0,loginMethodName:b="authenticate",loginUsing:p=void 0}){return{mode:e,publicKey:t,wireId:n,beforeRegister:i,serverError:r,registerPublicKeyUrl:a,registerMethodName:u,registerData:l,loginPublicKeyUrl:d,loginMethodName:b,loginUsing:p,processing:!1,browserSupported:w(),error:null,async submit(){return this.error=null,this.mode==="login"?this.submitLogin():this.submitRegister()},async submitRegister(){if(y(this.beforeRegister)&&!await this.beforeRegister(this))return;let o=this.publicKey;this.processing=!0;let c=y(this.registerData)?this.registerData():this.registerData;if(this.registerPublicKeyUrl){let g=await fetch(this.registerPublicKeyUrl,O(c));if(!g.ok)return this.processing=!1,this.notifyPublicKeyError();o=await g.json()}if(!this.isValidPublicKey(o))return this.processing=!1,this.notifyPublicKeyError();let f=window.Livewire.find(this.wireId);return S(o).then(g=>f.$call(this.registerMethodName,g)).catch(g=>this.error=g?.response?.data?.message||g).finally(()=>this.processing=!1)},async submitLogin(){let o=this.publicKey;if(this.processing=!0,this.loginPublicKeyUrl){let f=await fetch(this.loginPublicKeyUrl,O());if(!f.ok)return this.processing=!1,this.notifyPublicKeyError();o=await f.json()}if(!this.isValidPublicKey(o))return this.processing=!1,this.notifyPublicKeyError();let c=window.Livewire.find(this.wireId);return this.error=null,this.serverError=!1,T(o).then(f=>y(this.loginUsing)?this.loginUsing(f):c.$call(this.loginMethodName,f)).catch(f=>{this.error=f?.response?.data?.message||f,this.serverError=!0,c.$call("$refresh")}).finally(()=>this.processing=!1)},isValidPublicKey(o){return D(o)&&A(o,"challenge")&&A(o,this.mode==="login"?"rpId":"rp")},notifyPublicKeyError(){new FilamentNotification().danger().title("Error").body("We encountered a fatal error in the key generation process. Please try again later.").send()},hasErrors(o){return Object.keys(o?.__instance?.snapshot?.memo?.errors??{}).length>0}}}export{M as default};
